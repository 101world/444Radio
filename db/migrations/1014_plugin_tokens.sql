-- Migration 1014: Plugin API Token System
-- Adds plugin_tokens table for VST3 plugin authentication
-- Users generate a personal API token from their profile/plugin settings
-- Token is used as Bearer auth in all /api/plugin/* endpoints

-- Plugin API tokens table
CREATE TABLE IF NOT EXISTS plugin_tokens (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  clerk_user_id TEXT NOT NULL REFERENCES users(clerk_user_id) ON DELETE CASCADE,
  token TEXT NOT NULL UNIQUE,
  name TEXT NOT NULL DEFAULT 'Ableton Plugin',
  is_active BOOLEAN DEFAULT true,
  last_used_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  expires_at TIMESTAMPTZ,  -- NULL = never expires
  
  -- Rate limiting fields
  requests_today INTEGER DEFAULT 0,
  requests_reset_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index for fast token lookups (this is hit on every plugin API call)
CREATE INDEX IF NOT EXISTS idx_plugin_tokens_token ON plugin_tokens(token) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_plugin_tokens_user ON plugin_tokens(clerk_user_id);

-- Plugin purchases table (for $25 one-time license)
CREATE TABLE IF NOT EXISTS plugin_purchases (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  clerk_user_id TEXT NOT NULL REFERENCES users(clerk_user_id) ON DELETE CASCADE,
  payment_id TEXT,           -- Razorpay/PayPal payment ID
  payment_method TEXT,       -- 'razorpay', 'paypal', 'credits'
  amount_usd DECIMAL(10,2) NOT NULL DEFAULT 25.00,
  status TEXT NOT NULL DEFAULT 'completed',  -- 'completed', 'refunded'
  platform TEXT DEFAULT 'all',  -- 'windows', 'mac', 'all'
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_plugin_purchases_user ON plugin_purchases(clerk_user_id);

-- Plugin generation jobs (extends studio_jobs pattern for async plugin work)
CREATE TABLE IF NOT EXISTS plugin_jobs (
  id TEXT PRIMARY KEY,  -- UUID generated by API
  clerk_user_id TEXT NOT NULL,
  type TEXT NOT NULL,  -- 'music', 'effects', 'loops', 'stems', 'image', 'audio-boost'
  status TEXT NOT NULL DEFAULT 'queued',  -- 'queued', 'processing', 'completed', 'failed', 'cancelled'
  params JSONB DEFAULT '{}',
  replicate_prediction_id TEXT,
  output JSONB,  -- { audioUrl, imageUrl, stems: {vocals, drums, bass, ...}, loops: [...] }
  error TEXT,
  credits_cost INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_plugin_jobs_user ON plugin_jobs(clerk_user_id);
CREATE INDEX IF NOT EXISTS idx_plugin_jobs_status ON plugin_jobs(status) WHERE status IN ('queued', 'processing');
CREATE INDEX IF NOT EXISTS idx_plugin_jobs_created ON plugin_jobs(created_at DESC);

-- RLS policies
ALTER TABLE plugin_tokens ENABLE ROW LEVEL SECURITY;
ALTER TABLE plugin_purchases ENABLE ROW LEVEL SECURITY;
ALTER TABLE plugin_jobs ENABLE ROW LEVEL SECURITY;

-- Users can only see/manage their own tokens (idempotent: drop if exists first)
DO $$ BEGIN
  DROP POLICY IF EXISTS plugin_tokens_select ON plugin_tokens;
  DROP POLICY IF EXISTS plugin_tokens_insert ON plugin_tokens;
  DROP POLICY IF EXISTS plugin_purchases_select ON plugin_purchases;
  DROP POLICY IF EXISTS plugin_jobs_select ON plugin_jobs;
END $$;

CREATE POLICY plugin_tokens_select ON plugin_tokens FOR SELECT USING (clerk_user_id = current_setting('request.jwt.claims', true)::json->>'sub');
CREATE POLICY plugin_tokens_insert ON plugin_tokens FOR INSERT WITH CHECK (clerk_user_id = current_setting('request.jwt.claims', true)::json->>'sub');

-- Users can only see their own purchases
CREATE POLICY plugin_purchases_select ON plugin_purchases FOR SELECT USING (clerk_user_id = current_setting('request.jwt.claims', true)::json->>'sub');

-- Users can only see their own jobs
CREATE POLICY plugin_jobs_select ON plugin_jobs FOR SELECT USING (clerk_user_id = current_setting('request.jwt.claims', true)::json->>'sub');

-- Function to validate plugin token and return user ID
-- Using CREATE OR REPLACE so this is idempotent
CREATE OR REPLACE FUNCTION validate_plugin_token(p_token TEXT)
RETURNS TABLE (user_id TEXT, token_id UUID, is_valid BOOLEAN, error_message TEXT)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_token_record RECORD;
BEGIN
  -- Find active token
  SELECT pt.id, pt.clerk_user_id, pt.is_active, pt.expires_at,
         pt.requests_today, pt.requests_reset_at
  INTO v_token_record
  FROM plugin_tokens pt
  WHERE pt.token = p_token AND pt.is_active = true;
  
  IF v_token_record IS NULL THEN
    RETURN QUERY SELECT NULL::TEXT, NULL::UUID, false, 'Invalid or revoked token'::TEXT;
    RETURN;
  END IF;
  
  -- Check expiry
  IF v_token_record.expires_at IS NOT NULL AND v_token_record.expires_at < NOW() THEN
    RETURN QUERY SELECT NULL::TEXT, NULL::UUID, false, 'Token expired'::TEXT;
    RETURN;
  END IF;
  
  -- Rate limit: 100 requests per day
  IF v_token_record.requests_reset_at < NOW() - INTERVAL '24 hours' THEN
    -- Reset counter
    UPDATE plugin_tokens SET requests_today = 1, requests_reset_at = NOW() WHERE id = v_token_record.id;
  ELSIF v_token_record.requests_today >= 100 THEN
    RETURN QUERY SELECT NULL::TEXT, NULL::UUID, false, 'Daily rate limit exceeded (100/day)'::TEXT;
    RETURN;
  ELSE
    UPDATE plugin_tokens SET requests_today = requests_today + 1 WHERE id = v_token_record.id;
  END IF;
  
  -- Update last used
  UPDATE plugin_tokens SET last_used_at = NOW() WHERE id = v_token_record.id;
  
  RETURN QUERY SELECT v_token_record.clerk_user_id, v_token_record.id, true, NULL::TEXT;
END;
$$;
